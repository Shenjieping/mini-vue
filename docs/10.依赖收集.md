## 依赖手机

> 当用户更新了data里的数据之后要通知视图进行重写渲染

要更新视图其实就是去调用 update方法 `vm._update(vm._render())`

1. 创建一个Dep类，用于记录dep和Watcher之间的关系 `observer/dep.js`

```js
let id = 0;
export default class Dep {
  constructor() {
    this.id = id++; // 记录一个唯一的id，用于后面的去重
    this.subs = [];
  }
  depend() {
    // watcher 和 dep 的关系：一个watcher 对应多个depl，一个dep对应多个Watcher，他们之间要互相记录一下
    // this.subs.push(Dep.target); // 观察者模式，这样可能会重复调用
    // 让这个Watcher记住我的dep
    Dep.target.addDep(this);
  }
  notify() {
    this.subs.forEach(watcher => watcher.update())
  }
  addSub(watcher) { // 这里放的就是Watcher
    this.subs.push(watcher);
  }
}

// 创建两个方法，pushTarget用于保存当前的Watcher，popTarget 当渲染之后移除当前的Watcher
let stack = [];
// 目前可以做到将Watcher保存起来，和移除
export function pushTarget(watcher) {
  Dep.target = watcher;
  stack.push(watcher);
}

export function popTarget() {
  stack.pop();
  Dep.target = stack[stack.length - 1];
}
```

2. 在 `objerver/index.js` 当用户更新了数据，需要通知我们的dep进行数据更新，其实就是让Watcher执行。取值的时候，把当前的dep放入到Watcher中

```js
export function defineReactive(obj, key, value) {
  let dep = new Dep();
  observe(value);
  Object.defineProperty(obj, key, {
    get() {
      // 每个属性都对应着自己的渲染Watcher
      if (Dep.target) { // 如果当前有Watcher
        dep.depend(); // 我要将Watcher存起来
      }
      return value;
    },
    set(newValue) { // 设置值的时候做一些操作
      if (value === newValue) {
        return;
      }
      // console.log('update 视图更新');
      observe(newValue); // 如果新设置的值是一个对象，也要被监控
      value = newValue;
      dep.notify(); // 通知依赖更新操作
    }
  });
}
```

3. 当Watcher执行的之后，需要对dep做一个双向记录，并对多次取同一个属性的Watcher去重

```js
import { pushTarget, popTarget } from "./dep";

let id = 0;
export default class Watcher {
  constructor(vm, expOrFn, cb, options, isRenderWatcher) {
    this.vm = vm;
    this.cb = cb;
    this.id = id++;
    this.options = options;
    this.isRenderWatcher = isRenderWatcher;
    this.depsId = new Set(); // 去重当前的Watcher
    this.deps = [];

    this.getter = expOrFn; // 将内部传过来的函数放在getter属性上
    this.get(); // 调用get方法，会让渲染Watcher执行
  }
  get() {
    pushTarget(this); // 将当前的Watcher存起来
    this.getter(); // 执行的就是 vm._update
    popTarget(); // 移除Watcher
  }
  update () {
    this.get();
  }
  addDep (dep) {
    // watcher 不能放重读的dep，同样dep里不能放重复的Watcher
    let id = dep.id;
    if (!this.depsId.has(id)) {
      this.depsId.add(id);
      this.deps.push(dep);
      dep.addSub(this); // 让dep记住Watcher
    }
  }
}
```